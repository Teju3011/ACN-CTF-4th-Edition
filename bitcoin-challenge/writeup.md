# Bitcoin Whisper — Writeup (Organizer)

**Flag:** `acnctf{bitcoin_whisper_uncovered}`

This writeup explains exactly how the challenge was encoded and how a solver recovers the flag from the provided Base58Check addresses. It contains step‑by‑step decoding, intermediate values, and helpful commands a player could run (or use online tools) to solve the challenge.

---

## Challenge overview

* **Theme:** Bitcoin / Cryptography
* **Mechanics:** Each Bitcoin-like address in `addresses.txt` contains a small portion of the flag inside its Base58Check payload. The payload bytes have been XOR‑obfuscated with a repeating 4‑byte key derived from a riddle. Solvers must: `Base58Check decode → remove version byte → XOR with key → convert to ASCII → concatenate segments`.

---

## Design choices (organizer)

* Use real Base58Check encoding (version byte + payload + checksum) so `b58decode_check()` works and online Base58Check decoders accept the addresses.
* Hide flag text in the payload portion (not in checksum or version byte).
* XOR key derived from riddle: **100,000,000** (the number of satoshis in 1 BTC) → 4‑byte big‑endian `05 F5 E1 00`.
* Split flag into 5 segments for moderate complexity and to force combination.
* Optionally supply subtle hints, not the key itself.

---

## The flag (for organizers)

```
acnctf{bitcoin_whisper_uncovered}
```

---

## Provided addresses (in `addresses.txt`)

```
1RwiNHii8mHxZvCZ
1ShCZLNv7FNRKR9S
12i4iHUfHhcYSoWtrT
12i4DraQfTb5TsjU4b
14fFe7ixhA5
```

These were generated by taking each XORed segment, prepending a version byte `0x00`, computing the double SHA256 checksum (first 4 bytes), concatenating and Base58 encoding.

---

## Full encoding code (organizer)

```python
# encode.py (organizer)
import hashlib

ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

def b58encode(b: bytes) -> str:
    n = int.from_bytes(b, 'big')
    res = ''
    while n > 0:
        n, r = divmod(n, 58)
        res = ALPHABET[r] + res
    # leading zero bytes -> '1'
    for byte in b:
        if byte == 0:
            res = '1' + res
        else:
            break
    return res

flag_segments = [
    b"acnctf{",
    b"bitcoin",
    b"_whisper",
    b"_uncover",
    b"ed}"
]

key = 100_000_000
key_bytes = key.to_bytes(4, 'big')  # 0x05F5E100

addresses = []
for seg in flag_segments:
    # XOR the bytes
    xored = bytes([b ^ key_bytes[i % len(key_bytes)] for i, b in enumerate(seg)])
    # Prepend version byte
    payload = b"\x00" + xored
    # Checksum
    checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[:4]
    full_payload = payload + checksum
    addr = b58encode(full_payload)
    addresses.append(addr)

print('\n'.join(addresses))
```

---

## Decoding: step-by-step (what solvers must do)

This section walks through decoding the exact addresses that were supplied. We include the intermediate hex values and show the XOR steps for the first segment in detail.

### XOR key (derived from riddle)

* Riddle: *"Count what you cannot spend: 100 million of something tiny"*
* Integer: `100000000`
* 4‑byte big‑endian hex: `05 F5 E1 00`
* Repeat this 4‑byte sequence across each payload byte when XORing.

---

### Base58Check decoded hex (payloads shown with version byte)

After decoding each provided address with a Base58Check decoder (or using `base58.b58decode_check()`), the following hex strings were obtained:

1. `0064968f6371939a1f2cf002`
2. `00679c95636a9c8f4426fd39`
3. `005a82896976858472a1407ea8`
4. `005a808f636a838472b195158c`
5. `0060919c4116f5d6`

> Each string begins with `00` — that is the version byte (P2PKH). The remainder is the XORed payload. The last 4 bytes of each full decoded payload are the checksum; because we used `b58decode_check()` they are already validated and included in the decoded bytes above. For decoding the hidden message we remove the version byte and operate on the payload (the bytes following the `00`).

---

### Segment 1 — detailed XOR table

Raw decoded (with version):

```
00 64 96 8F 63 71 93 9A 1F 2C F0 02
```

Remove version byte (drop the first `00`):

```
64 96 8F 63 71 93 9A 1F 2C F0 02
```

Split into bytes and XOR with repeating key `05 F5 E1 00`:

| Index | Encoded byte | Key byte | XOR result |  ASCII (if printable) |
| ----- | -----------: | -------: | ---------: | --------------------: |
| 0     |         0x64 |     0x05 |       0x61 |                   'a' |
| 1     |         0x96 |     0xF5 |       0x63 |                   'c' |
| 2     |         0x8F |     0xE1 |       0x6E |                   'n' |
| 3     |         0x63 |     0x00 |       0x63 |                   'c' |
| 4     |         0x71 |     0x05 |       0x74 |                   't' |
| 5     |         0x93 |     0xF5 |       0x66 |                   'f' |
| 6     |         0x9A |     0xE1 |       0x7B |                   '{' |
| 7     |         0x1F |     0x00 |       0x1F | (non-printable / pad) |
| 8     |         0x2C |     0x05 |       0x29 |  ')' (likely padding) |
| 9     |         0xF0 |     0xF5 |       0x05 |       (non-printable) |
| 10    |         0x02 |     0xE1 |       0xE3 |       (non-printable) |

Interpretation: the first 7 printable bytes decode to `acnctf{` — these are the intended characters of segment 1. The trailing bytes are padding/checksum-related noise which can be ignored if they do not translate to printable characters.

---

### Segments 2–5 (results)

Applying the same process (remove leading `00`, XOR with `05 F5 E1 00` repeating) to the remaining payloads yields:

* Segment 2: `bitcoin`
* Segment 3: `_whisper`
* Segment 4: `_uncover`
* Segment 5: `ed}`

Putting them in order:

```
acnctf{bitcoin_whisper_uncovered}
```

---

## Quick decode script (player-friendly)

Provide this script in the challenge as a template (do not include the final flag). It helps beginners while preserving puzzle difficulty.

```python
#!/usr/bin/env python3
import base58

KEY = 100_000_000
KEY_BYTES = KEY.to_bytes(4, 'big')

segments = []
with open('addresses.txt') as f:
    for line in f:
        addr = line.strip()
        if not addr:
            continue
        decoded = base58.b58decode_check(addr)
        payload = decoded[1:]  # drop version
        original = bytes([b ^ KEY_BYTES[i % len(KEY_BYTES)] for i, b in enumerate(payload)])
        # try to decode printable prefix
        printable = ''.join(chr(c) for c in original if 32 <= c < 127)
        segments.append(printable)

print(''.join(segments))
```

---

## How a beginner can solve this with online tools

1. Use a **Base58Check decoder** (search online). Paste each address and get the decoded hex (version+payload+checksum).
2. Remove the first byte (version, usually `00`).
3. Use an online **Hex → Bytes** viewer if needed.
4. Use an online **XOR tool** (Cryptii, CyberChef, or similar). Input the payload hex and the repeating key `05F5E100` (or enter as bytes `05 F5 E1 00`).
5. Convert XOR output to ASCII.
6. Concatenate segments in order to get the flag.

---

## Organizer notes & potential tweaks

* To increase difficulty further:

  * Shuffle segments and include a subtle order clue in the challenge text.
  * Add a few decoy addresses whose decoded payloads XOR to garbage.
  * Use a longer or derived key (e.g., from a small calculation on a public blockchain value) instead of a plain satoshi constant.

* To help beginners without spoiling the challenge: include a small `hint.txt` file that nudges them toward "Base58Check" and the satoshi riddle rather than providing the key outright.

---

## Security / ethics note

* These addresses are **not real wallets** and do not expose any private keys or funds. The payloads are arbitrary bytes used only to carry cipher text for the puzzle. Do not attempt to broadcast any transactions or try to use these addresses on a network.

---

If you want, I can also export this writeup as a downloadable `writeup.md` file formatted for your GitHub repository (organizer-only).
